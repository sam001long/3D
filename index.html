<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D 運鏡模擬器（GLB 上傳）</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-slate-950">
    <div id="root"></div>

    <script type="module">
      import React, { Suspense, useEffect, useRef, useState } from 'https://cdn.jsdelivr.net/npm/react@18.2.0/+esm'
      import { createRoot } from 'https://cdn.jsdelivr.net/npm/react-dom@18.2.0/client/+esm'
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/+esm'
      import { Canvas, useFrame, useThree } from 'https://cdn.jsdelivr.net/npm/@react-three/fiber@8.15.19/+esm'
      import { OrbitControls, PerspectiveCamera, useHelper, useGLTF } from 'https://cdn.jsdelivr.net/npm/@react-three/drei@9.105.6/+esm'

      const deg2rad = (d) => (d * Math.PI) / 180
      const DISTANCE_SCALE = { CLOSE: 1.4, MEDIUM: 2.5, WIDE: 4.5 }
      const ANGLE_MAP = { BIRD: 60, HIGH: 30, LEVEL: 0, LOW: -20 }

      function computePose(t, { style, dist, elevDeg, speed, focus }) {
        const elev = deg2rad(elevDeg)
        const r = dist, y = r * Math.sin(elev), rh = Math.max(0.001, r * Math.cos(elev))
        const amp = Math.min(r * 0.35, focus.radius * 1.2)
        let x = rh, z = 0, phi = 0, ty = focus.center.y + focus.radius * 0.1
        switch (style) {
          case 'ORBIT': phi = t * speed; x = rh * Math.cos(phi); z = rh * Math.sin(phi); break
          case 'DOLLY': { const rr = r + amp * Math.sin(t * speed); const rrh = Math.max(0.001, rr * Math.cos(elev)); x = rrh; z = 0; break }
          case 'TRUCK': { const dx = amp * 0.6 * Math.sin(t * speed); x = rh + dx; z = 0; break }
          case 'CRANE': { const dy = amp * 0.6 * Math.sin(t * speed); x = rh; z = 0; return { position: [focus.center.x + x, ty + y + dy, focus.center.z + z], target: [focus.center.x, ty, focus.center.z] } }
          default: { x = rh; z = 0; break }
        }
        return { position: [focus.center.x + x, ty + y, focus.center.z + z], target: [focus.center.x, ty, focus.center.z] }
      }

      function Ground() {
        return React.createElement('group', null,
          React.createElement('mesh', { receiveShadow: true, rotation: [-Math.PI/2,0,0], position:[0,-0.001,0] },
            React.createElement('planeGeometry', { args:[40,40] }),
            React.createElement('meshStandardMaterial', { color:'#0b1220' })
          ),
          React.createElement('gridHelper', { args:[40,40,'#334155','#1f2937'], position:[0,0.001,0] }),
          React.createElement('axesHelper', { args:[1.2] }),
        )
      }

      function DefaultSubject() {
        return React.createElement('group', null,
          React.createElement('mesh', { castShadow: true, position:[0,0.8,0] },
            React.createElement('icosahedronGeometry', { args:[0.6,1] }),
            React.createElement('meshStandardMaterial', { metalness:0.1, roughness:0.4, color:'#a3bffa' })
          ),
          React.createElement('mesh', { castShadow: true, position:[0,0.25,0] },
            React.createElement('cylinderGeometry', { args:[0.35,0.5,0.5,24] }),
            React.createElement('meshStandardMaterial', { metalness:0.05, roughness:0.8, color:'#64748b' })
          ),
          React.createElement('mesh', { castShadow: true, position:[0,0.0,0] },
            React.createElement('cylinderGeometry', { args:[0.6,0.6,0.1,36] }),
            React.createElement('meshStandardMaterial', { metalness:0.05, roughness:0.9, color:'#94a3b8' })
          ),
        )
      }

      function useBlobURL(file) {
        const [url, setUrl] = useState(null)
        useEffect(() => { if (!file) { setUrl(null); return } const u = URL.createObjectURL(file); setUrl(u); return () => URL.revokeObjectURL(u) }, [file])
        return url
      }

      function loadTextureFromFile(file, { colorSpace = THREE.NoColorSpace, flipY = false } = {}) {
        return new Promise((resolve, reject) => {
          if (!file) return resolve(null)
          const url = URL.createObjectURL(file)
          const loader = new THREE.TextureLoader()
          loader.load(url, (tex) => { tex.flipY = flipY; tex.colorSpace = colorSpace; tex.anisotropy = 4; resolve(tex); URL.revokeObjectURL(url) }, undefined, (err) => { reject(err); URL.revokeObjectURL(url) })
        })
      }

      function applyTextures(root, maps) {
        root.traverse((obj) => {
          if (!obj.isMesh) return
          const mat = obj.material
          if (!mat || Array.isArray(mat)) return
          if (maps.baseColor) { if (!mat.map) mat.map = maps.baseColor; mat.map && (mat.map.needsUpdate = true) }
          if (maps.normal)    { if (!mat.normalMap) mat.normalMap = maps.normal; mat.normalMap && (mat.normalMap.needsUpdate = true) }
          if (maps.orm) {
            if (!mat.roughnessMap) mat.roughnessMap = maps.orm
            if (!mat.metalnessMap) mat.metalnessMap = maps.orm
            if (!mat.aoMap)        mat.aoMap        = maps.orm
            mat.roughnessMap && (mat.roughnessMap.needsUpdate = true)
            mat.metalnessMap && (mat.metalnessMap.needsUpdate = true)
            mat.aoMap && (mat.aoMap.needsUpdate = true)
          }
          mat.needsUpdate = true
        })
      }

      function useFocusFromObject(object3D) {
        const [focus, setFocus] = useState({ center: new THREE.Vector3(0, 0.45, 0), radius: 1.0, height: 1.2 })
        useEffect(() => {
          if (!object3D) return
          const box = new THREE.Box3().setFromObject(object3D)
          const size = new THREE.Vector3(); box.getSize(size)
          const center = new THREE.Vector3(); box.getCenter(center)
          const radius = Math.max(size.x, size.y, size.z) * 0.5 || 1.0
          setFocus({ center, radius, height: size.y })
        }, [object3D])
        return focus
      }

      function GLBModel({ glbFile, maps, onLoaded }) {
        const url = useBlobURL(glbFile)
        const { scene } = useGLTF(url)
        useEffect(() => { if (scene && onLoaded) onLoaded(scene) }, [scene, onLoaded])
        useEffect(() => { if (!scene) return; if (maps && (maps.baseColor || maps.normal || maps.orm)) applyTextures(scene, maps) }, [scene, maps])
        const groupRef = useRef()
        useEffect(() => { if (!scene || !groupRef.current) return; const box = new THREE.Box3().setFromObject(scene); const c = new THREE.Vector3(); box.getCenter(c); scene.position.sub(c) }, [scene])
        return React.createElement('group', { ref: groupRef }, scene && React.createElement('primitive', { object: scene }))
      }

      function OmniscientView({ t, style, dist, elevDeg, speed, fov, focus, content }) {
        const shotCamRef = useRef()
        useFrame(() => {
          const pose = computePose(t, { style, dist, elevDeg, speed, focus })
          if (shotCamRef.current) {
            shotCamRef.current.fov = fov
            shotCamRef.current.position.set(...pose.position)
            shotCamRef.current.lookAt(...pose.target)
            shotCamRef.current.updateProjectionMatrix()
          }
        })
        useHelper(shotCamRef, THREE.CameraHelper, '#60a5fa')
        return React.createElement(Canvas, { shadows: true, dpr:[1,2], camera:{ position: [6,4,6], fov: 55 } },
          React.createElement('color', { attach: 'background', args: ['#020617'] }),
          React.createElement('fog', { attach: 'fog', args: ['#020617', 20, 60] }),
          React.createElement('ambientLight', { intensity: 0.55 }),
          React.createElement('directionalLight', { castShadow: true, position: [6,8,4], intensity: 1.1, 'shadow-mapSize': [1024,1024] },
            React.createElement('orthographicCamera', { attach: 'shadow-camera', args: [-10,10,10,-10,0.5,50] })
          ),
          React.createElement(Ground, null),
          React.createElement(Suspense, { fallback: React.createElement(DefaultSubject,null) }, content),
          React.createElement(PerspectiveCamera, { ref: shotCamRef, makeDefault: false, near: 0.05, far: 200 }),
          React.createElement(OrbitControls, { makeDefault: true, enablePan: true, enableZoom: true, enableRotate: true })
        )
      }

      function CameraView({ t, style, dist, elevDeg, speed, fov, focus, content }) {
        const { camera } = useThree()
        useFrame(() => {
          const pose = computePose(t, { style, dist, elevDeg, speed, focus })
          camera.fov = fov
          camera.position.set(...pose.position)
          camera.lookAt(...pose.target)
          camera.updateProjectionMatrix()
        })
        return React.createElement(React.Fragment, null,
          React.createElement('color', { attach: 'background', args: ['#0b1020'] }),
          React.createElement('ambientLight', { intensity: 0.45 }),
          React.createElement('directionalLight', { position: [6,8,4], intensity: 1.0 }),
          React.createElement(Ground, null),
          React.createElement(Suspense, { fallback: React.createElement(DefaultSubject,null) }, content)
        )
      }

      function Controls({ style, setStyle, distance, setDistance, angle, setAngle, fov, setFov, speed, setSpeed, playing, setPlaying }) {
        return React.createElement('div', { className: 'flex flex-wrap items-center gap-3' },
          React.createElement('div', { className: 'flex items-center gap-2' },
            React.createElement('span', { className: 'text-xs uppercase tracking-wider text-slate-400' }, '運鏡'),
            React.create
